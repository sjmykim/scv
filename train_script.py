#
# This file is generated by SCV to run Ultralytics YOLO training externally.
#
# Copyright (C) 2025 SCV
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
#

import sys
import subprocess

if __name__ == '__main__':
    import multiprocessing
    multiprocessing.freeze_support()
    
    # Import (오프라인 환경 가정: 패키지는 번들된 venv에 존재해야 함)
    import os
    import torch
    # INI-based env overrides (optional)
    try:
        import configparser as _cp
        def _load_env_ini(_hint_dir: str = ''):
            # Priority: SCV_ENV_INI > fixed utils path > <script_dir>/scv_env.ini
            ini_candidates = []
            env_ini = os.environ.get('SCV_ENV_INI', '').strip()
            if env_ini:
                ini_candidates.append(env_ini)
            ini_candidates.append(r"c:/workspace/custom-widgets/scv/src/utils/scv_env.ini")
            if _hint_dir:
                ini_candidates.append(os.path.join(_hint_dir, 'scv_env.ini'))
            for _p in ini_candidates:
                try:
                    if _p and os.path.exists(_p):
                        cfg = _cp.ConfigParser()
                        cfg.read(_p, encoding='utf-8')
                        if cfg.has_section('env'):
                            for k, v in cfg.items('env'):
                                if v is None:
                                    continue
                                os.environ[k.upper()] = str(v)
                            print("[INFO] Loaded env from INI:", _p)
                        break
                except Exception as _e:
                    print("[WARN] Failed to load INI", _p, ":", _e)
        _load_env_ini(os.path.dirname(__file__) if '__file__' in globals() else os.getcwd())
    except Exception as _ee:
        print("[WARN] INI env loader failed:", _ee)
    # 0) 환경 강제 설정: PATH, PYTHONEXECUTABLE, 사용자 설정 파일 경로
    try:
        venv_scripts = os.path.dirname(sys.executable)
        os.environ['PATH'] = venv_scripts + os.pathsep + os.environ.get('PATH', '')
        os.environ['PYTHONEXECUTABLE'] = sys.executable
        # 학습 스크립트 디렉터리를 settings 저장소로 사용 (항상 존재하도록 보장)
        settings_dir = os.path.dirname(__file__) if '__file__' in globals() else os.getcwd()
        try:
            os.makedirs(settings_dir, exist_ok=True)
        except Exception:
            pass
        settings_path = os.path.join(settings_dir, 'ultralytics_settings.yaml')
        os.environ['ULTRALYTICS_SETTINGS'] = settings_path
        # 미리 settings 파일 생성 (python 경로를 현재 인터프리터로 지정)
        try:
            with open(settings_path, 'w', encoding='utf-8') as sf:
                sf.write('python: ' + sys.executable.replace('\\','/') + '\n')
        except Exception as ee:
            print("Warning: failed to prewrite ULTRALYTICS_SETTINGS: " + str(ee))
    except Exception as ee:
        print("Warning: failed to prepare environment: " + str(ee))

    # 1) 기존 사용자 환경의 오래된 설정 파일 제거/백업 (stale python 경로 방지)
    try:
        user_settings_dir = os.path.join(os.environ.get('APPDATA', ''), 'Ultralytics')
        user_settings_file = os.path.join(user_settings_dir, 'settings.yaml')
        backup_file = ''  # 사전 정의하여 예외적인 경로에서도 NameError 방지
        if os.path.exists(user_settings_file):
            backup_file = user_settings_file + '.bak'
            try:
                os.replace(user_settings_file, backup_file)
                print("Backed up old Ultralytics settings to: " + backup_file)
            except Exception:
                # 백업 실패 시 삭제 시도
                os.remove(user_settings_file)
                print("Removed old Ultralytics settings.yaml")
    except Exception as e:
        print("Warning: failed to cleanup user settings: " + str(e))

    # 2) Ultralytics가 현재 파이썬을 사용하게 강제 설정 후 import
    try:
        # Force Ultralytics to use our embedded venv python and a local settings file in the exp folder
        settings_dir = os.path.dirname(__file__) if '__file__' in globals() else os.getcwd()
        user_settings_file = os.path.join(settings_dir, 'ultralytics_settings.yaml')
        os.environ['ULTRALYTICS_SETTINGS'] = user_settings_file
        os.environ['ULTRALYTICS_CONFIG_DIR'] = settings_dir
        os.environ['ULTRALYTICS_PYTHON'] = sys.executable
        os.environ['PYTHONEXECUTABLE'] = sys.executable
        from ultralytics.utils import SETTINGS
        # Sanitize and fix previous wrong python path (with quotes or invalid)
        prev_python = str(SETTINGS.get('python', '') or '')
        # Remove any quotes from path
        prev_python = prev_python.replace('"', '').replace("'", '')
        if (not prev_python) or (not os.path.exists(prev_python)):
            SETTINGS['python'] = sys.executable
        else:
            SETTINGS['python'] = prev_python
        SETTINGS.save()
        print("Ultralytics settings file: " + user_settings_file)
        print("Ultralytics python set to: " + str(SETTINGS.get('python', '')))
    except Exception as e:
        print("Warning: failed to set Ultralytics python: " + str(e))

    from ultralytics import YOLO
    # Enforce correct python after import in case Ultralytics overwrote it
    try:
        from ultralytics.utils import SETTINGS as S3
        final_py = str(S3.get('python', '') or '')
        # Remove any quotes from path
        final_py = final_py.replace('"', '').replace("'", '')
        if (not final_py) or (not os.path.exists(final_py)):
            S3['python'] = sys.executable
            S3.save()
            print("Rewrote Ultralytics SETTINGS python to: " + sys.executable)
        else:
            print("Ultralytics SETTINGS python verified: " + final_py)
    except Exception as verr:
        print("Warning: post-import SETTINGS verify failed: " + str(verr))

    # 3) 검증 및 폴백: 잘못된 python 경로가 남아 있으면 교정
    try:
        from ultralytics.utils import SETTINGS as S2
        print("SETTINGS python after import: " + str(S2.get('python')))
        if not os.path.exists(S2.get('python', '')):
            S2['python'] = sys.executable
            S2.save()
            print("SETTINGS python corrected to: " + sys.executable)
    except Exception as e:
        print("Warning: failed to verify SETTINGS: " + str(e))

    # --- 빠른 학습 설정(스모크) 지원: 환경변수로 기본값 덮어쓰기 ---
    epochs = 100  # 기본값으로 조정 가능
    batch_size = 4
    input_size = 640
    try:
        _env_epochs = os.environ.get('SCV_SMOKE_EPOCHS')
        if _env_epochs and str(_env_epochs).isdigit():
            epochs = int(_env_epochs)
        _env_batch = os.environ.get('SCV_SMOKE_BATCH')
        if _env_batch and str(_env_batch).isdigit():
            batch_size = int(_env_batch)
        _env_imgsz = os.environ.get('SCV_SMOKE_IMGSZ')
        if _env_imgsz and str(_env_imgsz).isdigit():
            input_size = int(_env_imgsz)
    except Exception:
        pass

    print("Starting YOLO training...")
    print("sys.executable: " + sys.executable)
    print("Dataset: " + "path/to/dataset.yaml")  # 설정 파일에서 주입될 예정
    print("Epochs: " + str(epochs))
    print("Batch size: " + str(batch_size))
    print("torch: " + str(torch.__version__) + " cuda_available=" + str(torch.cuda.is_available()) + " cuda_count=" + str(torch.cuda.device_count()))

    # Decide device at runtime to avoid invalid CUDA selection on non-CUDA machines
    device_arg = '0' if torch.cuda.is_available() else 'cpu'

    model = YOLO("yolo11n.pt")  # 기본 모델, 설정에서 변경 가능

    # Paths for training (경로 정규화)
    dataset_path = "path/to/dataset.yaml"  # 실제 사용 시 SCV에서 주입
    project_path = "runs/train"  # 실제 사용 시 SCV에서 주입

    print("Using dataset path: " + str(dataset_path))
    print("Using project path: " + str(project_path))
    print("Using device: " + str(device_arg))
    # Hint CUDA devices via env for child libs
    if str(device_arg).lower() != 'cpu':
        try:
            os.environ['CUDA_VISIBLE_DEVICES'] = str(device_arg)
        except Exception:
            pass

    try:
        model.train(data=dataset_path,
                    epochs=epochs, 
                    save_period=100, 
                    batch=batch_size, 
                    imgsz=input_size, 
                    device=device_arg, 
                    amp=False,
                    pretrained=False,
                    name="exp_run",
                    project=project_path,
                    hsv_h=0, hsv_s=0, hsv_v=0, fliplr=0.3, translate=0, patience=0)
    except KeyboardInterrupt:
        print("Training interrupted by user (Ctrl+C)")
        sys.exit(130)

    print("Training completed!")

    # === Auto export (ONNX and ENGINE) in the same external environment ===
    try:
        import subprocess as _sp
        # exp_root = parent of project_path (project_path == <exp_root>/tmp)
        exp_root = os.path.dirname(project_path)
        export_py = os.path.join(exp_root, 'export_script.py')

        def _run_and_stream(cmd, log_path):
            print('Executing:', ' '.join(cmd))
            rc = -1
            try:
                with open(log_path, 'a', encoding='utf-8') as lf:
                    _env = os.environ.copy()
                    # Ensure UTF-8 streams from child Python process
                    _env['PYTHONIOENCODING'] = 'utf-8'
                    proc = _sp.Popen(
                        cmd,
                        stdout=_sp.PIPE,
                        stderr=_sp.STDOUT,
                        text=True,
                        bufsize=1,
                        encoding='utf-8',
                        errors='replace',
                        env=_env
                    )
                    for line in proc.stdout:
                        line = line.rstrip('\n')
                        print('[export]', line)
                        try:
                            lf.write(line + '\n')
                        except Exception:
                            pass
                    rc = proc.wait()
            except Exception as pe:
                print('Warning: failed to run export process:', pe)
            return rc

        if os.path.exists(export_py):
            onnx_log = os.path.join(exp_root, 'export_onnx.log')
            engine_log = os.path.join(exp_root, 'export_engine.log')
            print('Running export_script.py for ONNX...')
            onnx_rc = _run_and_stream([sys.executable, export_py, '--format', 'onnx'], onnx_log)
            print('ONNX export exit code:', onnx_rc)
            print('Running export_script.py for TensorRT engine...')
            _engine_cmd = [sys.executable, export_py, '--format', 'engine']
            # Pass trtexec and cuda bin if available via env
            _trtexec = os.environ.get('TENSORRT_TRTEXEC', '').strip()
            if _trtexec:
                _engine_cmd += ['--trtexec', _trtexec]
            _cuda_bin = os.environ.get('SCV_CUDA_BIN', '').strip()
            if not _cuda_bin and os.environ.get('CUDA_PATH'):
                _cuda_bin = os.path.join(os.environ['CUDA_PATH'], 'bin')
            if _cuda_bin:
                _engine_cmd += ['--cuda_bin', _cuda_bin]
            engine_rc = _run_and_stream(_engine_cmd, engine_log)
            print('Engine export exit code:', engine_rc)
        else:
            print('Warning: export_script.py not found at', export_py)

        # Copy artifacts to <exp_root>/model (after exports)
        try:
            import shutil as _shutil
            model_dir = os.path.join(exp_root, 'model')
            os.makedirs(model_dir, exist_ok=True)
            # Ultralytics may create exp_run, exp_run2, ... Choose the newest exp_run* directory
            weights_parent = project_path
            try:
                exp_dirs = [d for d in os.listdir(weights_parent) if d.startswith('exp_run') and os.path.isdir(os.path.join(weights_parent, d))]
                exp_dirs.sort()
                selected = exp_dirs[-1] if exp_dirs else 'exp_run'
            except Exception:
                selected = 'exp_run'
            weights_dir = os.path.join(weights_parent, selected, 'weights')
            print("[copy] Using weights_dir: " + weights_dir)
            # Copy best.pt
            pt_src = os.path.join(weights_dir, 'best.pt')
            if os.path.exists(pt_src):
                _shutil.copy2(pt_src, os.path.join(model_dir, 'best.pt'))
                print("[copy] best.pt -> " + os.path.join(model_dir, 'best.pt'))
            else:
                print("[copy] best.pt not found at " + pt_src)
            # Copy best.onnx / best.engine if present
            onnx_src = os.path.join(weights_dir, 'best.onnx')
            if os.path.exists(onnx_src):
                _shutil.copy2(onnx_src, os.path.join(model_dir, 'best.onnx'))
                print("[copy] best.onnx -> " + os.path.join(model_dir, 'best.onnx'))
            eng_src = os.path.join(weights_dir, 'best.engine')
            if os.path.exists(eng_src):
                _shutil.copy2(eng_src, os.path.join(model_dir, 'best.engine'))
                print("[copy] best.engine -> " + os.path.join(model_dir, 'best.engine'))
            # Always ensure config.ini exists next to exported artifacts (standalone writer)
            try:
                cfg_path = os.path.join(model_dir, 'config.ini')
                # 환경변수로 최소 작성기 비활성화 가능
                _min_cfg_flag = os.environ.get('SCV_MIN_CFG', '1')
                if os.path.exists(cfg_path):
                    print("[copy] config.ini already exists, skip overwrite: " + cfg_path)
                elif _min_cfg_flag != '1':
                    print("[copy] config.ini minimal writer disabled by SCV_MIN_CFG, skip create: " + cfg_path)
                else:
                    import configparser as _cp
                    cfg = _cp.ConfigParser()
                    cfg['model'] = {}
                    if os.path.exists(os.path.join(model_dir, 'best.pt')):
                        cfg['model']['weights'] = 'best.pt'
                    if os.path.exists(os.path.join(model_dir, 'best.onnx')):
                        cfg['model']['export_onnx'] = 'best.onnx'
                    if os.path.exists(os.path.join(model_dir, 'best.engine')):
                        cfg['model']['export_engine'] = 'best.engine'
                    with open(cfg_path, 'w', encoding='utf-8') as cf:
                        cfg.write(cf)
                    print("[copy] config.ini (created) -> " + cfg_path)
            except Exception as exc:
                print('Warning: config.ini write failed:', exc)
        except Exception as ce:
            print('Warning: copy artifacts failed:', ce)
    except Exception as ee:
        print('Warning: auto export step failed:', ee)

    # 학습 및 내보내기 단계가 예외 없이 완료되었음을 표시하는 마커 파일 생성
    try:
        with open(os.path.join(os.path.dirname(project_path), 'TRAIN_DONE'), 'w', encoding='utf-8') as mf:
            mf.write('ok\n')
    except Exception:
        pass
